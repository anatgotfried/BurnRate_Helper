<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Testing - BurnRate AI Meal Planner</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
            background: #f8fafc;
        }
        h1 { color: #1e293b; }
        #status {
            padding: 1rem;
            background: white;
            border-radius: 8px;
            margin: 1rem 0;
            border-left: 4px solid #6366f1;
        }
        #results {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            margin-top: 2rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        th {
            background: #f1f5f9;
            font-weight: 600;
        }
        .success { color: #10b981; }
        .failed { color: #ef4444; }
        .warning { color: #f59e0b; }
        button {
            padding: 0.75rem 1.5rem;
            background: #6366f1;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
        }
        button:hover { background: #4f46e5; }
        button:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
        }
        pre {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>üß™ Model Testing Suite - BurnRate AI Meal Planner</h1>
    
    <div id="status">
        <strong>Status:</strong> <span id="statusText">Ready to test</span>
    </div>
    
    <button id="startTestBtn" onclick="runAllTests()">üöÄ Start Testing All Models</button>
    <button id="downloadBtn" onclick="downloadResults()" style="margin-left: 1rem; background: #10b981;" disabled>üì• Download Results</button>
    
    <div id="results"></div>
    
    <script src="macro-calculator.js"></script>
    <script src="cost-calculator.js"></script>
    <script src="corpus-filter.js"></script>
    <script>
        const API_URL = 'https://burn-rate-helper.vercel.app';
        
        const MODELS_TO_TEST = [
            'google/gemini-2.5-flash',
            'google/gemini-2.5-pro',
            'google/gemini-2.0-flash-001',
            'google/gemini-2.0-flash-exp:free',
            'mistralai/mistral-small-3.2-24b-instruct',
            'qwen/qwen-2.5-72b-instruct',
            'openai/gpt-4o-mini',
            'anthropic/claude-3.5-sonnet',
            'openai/gpt-4o'
        ];
        
        let testResults = [];
        
        const TEST_PROFILE = {
            weight_kg: 70,
            height_cm: 175,
            gender: 'male',
            training_phase: 'base',
            goal: 'performance',
            diet_pattern: 'omnivore',
            gi_tolerance: 'medium',
            sweat_rate: '1000',
            timezone: 'Asia/Jerusalem',
            populations: ['masters']
        };
        
        const TEST_WORKOUT = {
            type: 'run',
            duration_min: 60,
            intensity: 'moderate',
            startTime: '09:00',
            temp_c: 20,
            humidity_pct: 60
        };
        
        async function testModel(modelId, index) {
            const statusText = document.getElementById('statusText');
            statusText.textContent = `Testing ${index}/${MODELS_TO_TEST.length}: ${modelId}...`;
            
            const startTime = Date.now();
            const result = {
                model: modelId,
                model_name: modelId.split('/').pop(),
                test_number: index,
                success: false,
                error: null,
                duration_ms: 0,
                usage: null,
                cost: null,
                meal_count: 0,
                truncated: false,
                auto_fixed: false
            };
            
            try {
                const context = {
                    athlete: TEST_PROFILE,
                    workouts: [TEST_WORKOUT],
                    calculated_targets: calculateDailyTargets(TEST_PROFILE, [TEST_WORKOUT])
                };
                
                const prompt = `Generate a daily meal plan for a 70kg male athlete with 60min moderate run at 09:00.
Return ONLY valid JSON with: athlete_summary, meals array (with foods, totals, rationale, israel_alternatives), daily_totals, key_recommendations.`;
                
                const response = await fetch(`${API_URL}/api/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: modelId,
                        prompt: prompt,
                        max_tokens: 6000
                    })
                });
                
                const data = await response.json();
                result.duration_ms = Date.now() - startTime;
                result.usage = data.usage;
                result.auto_fixed = data.auto_fixed || false;
                result.truncated = data.truncated || false;
                
                if (data.success && data.meal_plan) {
                    result.success = true;
                    result.meal_count = data.meal_plan.meals?.length || 0;
                    
                    if (data.usage && calculateCost) {
                        const costInfo = calculateCost(modelId, data.usage);
                        result.cost = costInfo.totalCost;
                    }
                } else {
                    result.error = data.error || 'Unknown error';
                }
                
            } catch (error) {
                result.duration_ms = Date.now() - startTime;
                result.error = error.message;
            }
            
            return result;
        }
        
        async function runAllTests() {
            document.getElementById('startTestBtn').disabled = true;
            testResults = [];
            
            for (let i = 0; i < MODELS_TO_TEST.length; i++) {
                const result = await testModel(MODELS_TO_TEST[i], i + 1);
                testResults.push(result);
                
                // If failed, try Claude as fallback
                if (!result.success && !MODELS_TO_TEST[i].includes('claude')) {
                    const statusText = document.getElementById('statusText');
                    statusText.textContent = `‚ùå ${MODELS_TO_TEST[i]} failed, trying Claude fallback...`;
                    
                    const claudeResult = await testModel('anthropic/claude-3.5-sonnet', i + 0.5);
                    claudeResult.is_fallback = true;
                    claudeResult.fallback_for = MODELS_TO_TEST[i];
                    testResults.push(claudeResult);
                    
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                updateResultsTable();
                
                if (i < MODELS_TO_TEST.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                }
            }
            
            document.getElementById('statusText').textContent = '‚úÖ All tests complete!';
            document.getElementById('downloadBtn').disabled = false;
        }
        
        function updateResultsTable() {
            const resultsDiv = document.getElementById('results');
            
            const primaryResults = testResults.filter(r => !r.is_fallback);
            const successful = primaryResults.filter(r => r.success).length;
            
            let html = `
                <h2>Test Results (${primaryResults.length} models tested)</h2>
                <p><strong>Success Rate:</strong> ${successful}/${primaryResults.length} (${Math.round(successful/primaryResults.length*100)}%)</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Model</th>
                            <th>Status</th>
                            <th>Meals</th>
                            <th>Time</th>
                            <th>Cost</th>
                            <th>Notes</th>
                            <th>Recommendation</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            primaryResults.forEach((result, idx) => {
                const fallback = testResults.find(r => r.is_fallback && r.fallback_for === result.model);
                
                let recommendation = '';
                if (result.success && result.meal_count >= 5 && !result.truncated) {
                    recommendation = '‚úÖ KEEP - Works well';
                } else if (result.success && result.auto_fixed) {
                    recommendation = '‚ö†Ô∏è KEEP with caution - Needs auto-fix';
                } else if (result.truncated) {
                    recommendation = '‚ùå REMOVE - Truncates responses';
                } else if (!result.success && fallback?.success) {
                    recommendation = '‚ùå REMOVE - Unreliable (Claude works)';
                } else if (!result.success) {
                    recommendation = '‚ùå REMOVE - Does not work';
                }
                
                let notes = [];
                if (result.auto_fixed) notes.push('üîß Auto-fixed');
                if (result.truncated) notes.push('‚ö†Ô∏è Truncated');
                if (result.error) notes.push(result.error.substring(0, 40));
                if (fallback) notes.push(`Claude fallback: ${fallback.success ? '‚úÖ' : '‚ùå'}`);
                
                html += `
                    <tr>
                        <td>${idx + 1}</td>
                        <td>${result.model_name}</td>
                        <td class="${result.success ? 'success' : 'failed'}">${result.success ? '‚úÖ Success' : '‚ùå Failed'}</td>
                        <td>${result.meal_count || 0}</td>
                        <td>${(result.duration_ms / 1000).toFixed(1)}s</td>
                        <td>${result.cost === null ? 'N/A' : result.cost === 0 ? 'FREE' : '$' + result.cost.toFixed(4)}</td>
                        <td>${notes.join(', ')}</td>
                        <td>${recommendation}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            resultsDiv.innerHTML = html;
        }
        
        function downloadResults() {
            const report = {
                test_date: new Date().toISOString(),
                test_profile: TEST_PROFILE,
                test_workout: TEST_WORKOUT,
                results: testResults,
                summary: {
                    total_tested: testResults.filter(r => !r.is_fallback).length,
                    successful: testResults.filter(r => !r.is_fallback && r.success).length,
                    failed: testResults.filter(r => !r.is_fallback && !r.success).length,
                    auto_fixed: testResults.filter(r => !r.is_fallback && r.auto_fixed).length
                }
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `model-test-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
